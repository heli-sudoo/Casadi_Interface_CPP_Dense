
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <chrono> // system clock
#include <memory> // smart pointer
#include <thread>

#include "Dyn_FL.h"
#include "Dyn_FL_par.h"
#include "Dyn_FS.h"
#include "Dyn_FS_par.h"
#include "Dyn_BS.h"
#include "Dyn_BS_par.h"
#include "Jacob_F.h"
#include "Jacob_B.h"
#include "Imp_B.h"
#include "Imp_B_par.h"
#include "Imp_F.h"
#include "Imp_F_par.h"
#include "Dyn_FL_sub.h"
#include "Dyn_FL_sub_par.h"
#include "dynamics.h"

using namespace std::this_thread;

int main()
{
    cout << "This code benchmark runtime of dynamics and dynamics partials generated by CasadiGen." << endl;

    int xsize=14, usize=4, ysize=2, qsize=7;
    DVec x(xsize), x_next(xsize), u(usize), y(ysize), q(qsize), qd(qsize);
    DMat A(xsize, xsize);
    DMat B(xsize, usize);
    DMat C(ysize, xsize);
    DMat D(ysize, usize);
    DMat Px(xsize, xsize);
    DMat Pu(xsize, usize);
    DMat gx(ysize, xsize);
    DMat gu(ysize, usize);
    DMat J(ysize, qsize);
    DMat Jd(ysize, qsize);

    u.setZero();
    q << 0, -0.1093, -0.1542, 1.0957, -2.2033, 0.9742, -1.7098;
    qd << 0.9011, 0.2756, 0.7333, 0.0446, 0.0009, 1.3219, 2.7346;
    x << q, qd;

    int mode = 1;
    int foot = 1;
    _dt = 0.001;
    _Ac.setZero();
    _Bc.setZero();
    _xdot = DVec::Zero(xsize);
    _Ac = DMat::Zero(xsize, xsize);
    _Bc = DMat::Zero(xsize, usize);


    
    sleep_for(microseconds(1000));

    auto start = high_resolution_clock::now();
    int total_trials = 10000;
    for (int i = 0; i < total_trials; i++)
    {
        dynamics(x, u, x_next, y, mode);
        dynamics_par(x, u, A, B, C, D, mode);
        // resetmap(x, x_next, y, mode);
        // resetmap_par(x, Px, Pu, gx, gu, mode);
        // FootJacobian(x, J, Jd, foot);
    }

    auto stop = high_resolution_clock::now();
    auto duration = duration_cast<microseconds>(stop - start);
    cout << "Runtime : " << duration.count() / total_trials << " microseconds " << endl;
    
    std::cout << "x_next = \n" << x_next <<std::endl;
    // cout << "fx = \n"
    //      << MatrixXd(A) << endl;
    // cout << "fu = \n"
    //      << MatrixXd(B) << endl;
    // cout << "gx = \n"
    //      << MatrixXd(C) << endl;
    // cout << "gu = \n"
    //      << MatrixXd(D) << endl;
}


void dynamics(DVec x, DVec u, DVec &x_next, DVec &y, int mode)
{
    
    vector<DMat> arg = {x, u};
    vector<DVec*> res = {&_xdot, &y};
    switch (mode)
    {
    case 2:
    case 4: // flight
        casadi_interface<DVec>(arg, res,  Dyn_FL, Dyn_FL_sparsity_out, Dyn_FL_work);
        break;
    case 1: // back stance
        casadi_interface<DVec>(arg, res,  Dyn_BS, Dyn_BS_sparsity_out, Dyn_BS_work);
        break;
    case 3: // front stance
        casadi_interface<DVec>(arg, res,  Dyn_FS, Dyn_FS_sparsity_out, Dyn_FS_work);
        break;
    }
    // std::cout << "res[0] = \n" <<  res[0]<<std::endl;
    // std::cout << "_xdot = \n" <<  _xdot<<std::endl;
    /* Descrete-time dynamics*/
    x_next = x + _xdot * _dt;
}

void dynamics_par(DVec x, DVec u, DMat &A, DMat &B, DMat &C, DMat &D, int mode)
{
   vector<DMat> arg = {x, u};
   vector<DMat*> res = {&_Ac, &_Bc, &C, &D};

    switch (mode)
    {
    case 2:
    case 4: // flight
        casadi_interface<DMat>(arg, res, Dyn_FL_par, Dyn_FL_par_sparsity_out, Dyn_FL_par_work);
        break;
    case 1: // back stance
        casadi_interface<DMat>(arg, res, Dyn_BS_par, Dyn_BS_par_sparsity_out, Dyn_BS_par_work);
        break;
    case 3: // front stance
        casadi_interface<DMat>(arg, res, Dyn_FS_par, Dyn_FS_par_sparsity_out, Dyn_FS_par_work);
        break;
    } 

    A = StateMat::Identity() + _Ac * _dt;
    B = _Bc * _dt;
   
}

void resetmap(DVec x, DVec &x_next, DVec &y, int mode)
{
    vector<DMat> arg = {x};
    vector<DVec*> res = {&x_next, &y};

    switch (mode)
    {
    case 1:
    case 3:
        x_next = x;
        break;
    case 2: //front impact
        casadi_interface<DVec>(arg, res, Imp_F, Imp_F_sparsity_out, Imp_F_work);
        break;
    case 4: // back impact
        casadi_interface<DVec>(arg, res, Imp_B, Imp_B_sparsity_out, Imp_B_work);
        break;
    }

    
}

void resetmap_par(DVec x, DMat &Px, DMat &Pu, DMat &gx, DMat &gu, int mode)
{
    vector<DMat> arg = {x};
    vector<DMat*> res = {&Px, &Pu, &gx, &gu};    

    switch (mode)
    {
    case 1:
    case 3: // smooth transition
        Px = StateVec::Identity();
        Pu.setZero();
        gx.setZero();
        gu.setZero();
        break;
    case 2: // front impact
        casadi_interface<DMat>(arg, res, Imp_F_par, Imp_F_par_sparsity_out, Imp_F_par_work);
        break;
    case 4: // back impact
        casadi_interface<DMat>(arg, res, Imp_B_par, Imp_B_par_sparsity_out, Imp_B_par_work);
        break;
    }   
}

void FootJacobian(DVec x, DMat &J, DMat &Jd, int foot)
{
   vector<DMat> arg = {x};
   vector<DMat*> res = {&J, &Jd};

    if (1 == foot) // front foot
    {
       casadi_interface<DMat>(arg, res, Jacob_F, Jacob_F_sparsity_out, Jacob_F_work);
    }
    else if (2 == foot) // back foot
    {
       casadi_interface<DMat>(arg, res, Jacob_B, Jacob_B_sparsity_out, Jacob_B_work);
    }

}


/*
  @brief: Get the numerical evaluation of a CasadiGen function and the output sparsity pattern
  @params: 
          arg: double ptr to an array of pointers whose element points to an input variable
          res: double ptr to an array of pointers whose element points to an output variable
          row: double ptr to an array of pointers wholse ele points to a const array specifying row information of the sparse output
          col: double ptr to an array of pointers wholse ele points to a const array specifying col information of the sparse output
*/

template <typename T>
void casadi_interface(vector<DMat> &ARG, vector<T*> RES,
                      int f(const double **, double **, int_T *, double *, int),
                      const int_T *f_sparse_out(int_T),
                      int f_work(int_T *, int_T *, int_T *, int_T *))
{
    // function evaluation
    double *res[RES.size()], *arg[ARG.size()];
    int_T sz_arg, sz_res, sz_iw, sz_w, *iw = nullptr;
    double *w = nullptr;

    // reformat input argument structure
    for (int arg_idx = 0; arg_idx < ARG.size(); arg_idx++)
    {
        arg[arg_idx] = ARG[arg_idx].data();
    }
    
    // create memory to store the function output
    for (int res_idx = 0; res_idx < RES.size(); res_idx++)
    {
        res[res_idx] = new double[RES[res_idx]->size()];
    }    
    f_work(&sz_arg, &sz_res, &sz_iw, &sz_w);

    iw = new int_T[sz_iw];
    w = new double[sz_w];

    // get function output
    f((const double **)arg, res, iw, w, 1);

    // get sparsity pattern
    const int_T *sppattern;
    const int_T *rowinfo, *colinfo;
    int nnz;

    int nrow, ncol;
    for (size_t idx_res = 0; idx_res < sz_res; idx_res++)
    {
        sppattern = f_sparse_out(idx_res); // get the sparsity pattern (pointer to const array) for the ith output
        nrow = sppattern[0];
        ncol = sppattern[1];        

        assert(nrow == RES[idx_res]->rows());
        assert(ncol == RES[idx_res]->cols());

        colinfo = sppattern + 2;
        rowinfo = colinfo + ncol + 1;
        nnz = colinfo[ncol];

        // get data from res to RES
        int nzidx = 0;
        for (int colidx = 0; colidx < ncol; colidx++)
        {   
            while (nzidx < colinfo[colidx+1])
            {
                RES[idx_res]->coeffRef(rowinfo[nzidx], colidx) = res[idx_res][nzidx];
                nzidx++;
            }
            
        }
        
    }
    
    // delete dynamic memory
    if(nullptr != iw) delete [] iw;
    if(nullptr !=w) delete [] w;

    for (int res_idx = 0; res_idx < RES.size(); res_idx++)
    {
        if(nullptr != res[res_idx]) delete [] res[res_idx];
    }

}
